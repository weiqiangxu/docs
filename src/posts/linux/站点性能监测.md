# 性能测试与基准测试完全指南

## 一、概述

本文档整合了性能测试、基准测试、压测工具使用以及相关代码实现的完整内容，旨在帮助开发者全面了解如何进行应用性能测试和优化。

## 二、什么是性能测试与基准测试

在开发高性能应用时，我们需要关注以下几个方面：

1. 知道自己应用哪个模块哪个接口响应最慢
2. 知道应用随着请求数量增加哪块最薄弱，最容易出现短板
3. 知道自己站点消费请求数量最大值，做出相应的服务降级、动态扩容、限流、熔断等操作

性能测试主要包括以下内容：
- bench mark 基准测试单元测试验证消耗
- pprof 火焰图线上应用runtime采集CPU\协程\堆栈等
- hey 性能压力测试工具获取吞吐、QPS （最低标准是500并发请求成功率80%+）
- prometheus指标采集获取各个URL接口响应时长占比分布
- 性能测试监控TP50、TP99、TP999

## 三、QPS与并发的关系

### QPS的定义

接口性能的最大QPS，是在不断追加并发数量，当程序内部Redis或MySQL等其他依赖出现宕机或者内存爆满的条件下，能够承载的最大每秒钟处理数量。这就是这个接口的最大QPS。

可以根据这个QPS做一些保护服务的错误比如限流。

### QPS和并发的区别与联系

并发数和QPS不是同一个东西，但是并发数会影响QPS。

**举例说明**：
- 并发10的情况下接口的响应时长1ms，那么可以计算10*1000=10000此时的QPS
- 并发变成了100的时候接口的响应时长变成了500ms，此时100*2=200此时的QPS
- 并发是10000的时候，接口直接崩溃，何来QPS

正常情况下，并发数增高接口响应时间变长，QPS在低并发到高并发的情况下，会先从小到大，到达峰值之后会降低，最后应用直接宕机。这个临界点，也就是应用的最大QPS。

## 四、性能测试工具详解

### 1. hey工具

Hey是一个HTTP负载生成器，可以用于对Web应用进行性能测试。

#### Hey工具参数说明

```
Usage: hey [options...] <url>
Options:
  // 指定运行的总请求数。默认值为200。
  -n  Number of requests to run. Default is 200.
  // 客户端并发执行的请求数，默认为50。总请求数不能小于并发数。
  -c  Number of workers to run concurrently. Total number of requests cannot
      be smaller than the concurrency level. Default is 50.
  // 客户端发送请求的速度限制，以每秒响应数QPS为单位，默认没有限制。
  -q  Rate limit, in queries per second (QPS) per worker. Default is no rate limit.
  // 发送请求的持续时长，超时后程序停止并退出。若指定了持续时间，则忽略总请求数(-n)，例如-z 10s，-z 3m
  -z  Duration of application to send requests. When duration is reached,
      application stops and exits. If duration is specified, n is ignored.
      Examples: -z 10s -z 3m.
  // 输出类型。若没有提供，则打印摘要。CSV是唯一支持的格式，结果以逗号分隔各个指标项。
  -o  Output type. If none provided, a summary is printed.
      "csv" is the only supported alternative. Dumps the response
      metrics in comma-separated values format.
  // HTTP方法，例如GET，POST，PUT，DELETE，HEAD，OPTIONS方法
  -m  HTTP method, one of GET, POST, PUT, DELETE, HEAD, OPTIONS.
  // HTTP请求头，可以用-H连续添加多个请求头。
  -H  Custom HTTP header. You can specify as many as needed by repeating the flag.
      For example, -H "Accept: text/html" -H "Content-Type: application/xml" .
  // 每个请求的超时时间（以秒为单位）。默认值为20s，数值0代表永不超时。
  -t  Timeout for each request in seconds. Default is 20, use 0 for infinite.
  // HTTP响应头
  -A  HTTP Accept header.
  // HTTP请求正文
  -d  HTTP request body.
  // HTTP请求正文文件
  -D  HTTP request body from file. For example, /home/user/file.txt or ./file.txt.
  // 内容类型，默认为" text / html"。
  -T  Content-type, defaults to "text/html".
  // 基本身份验证，用户名：密码。
  -a  Basic authentication, username:password.
  // HTTP代理地址作, 使用host:port格式。
  -x  HTTP Proxy address as host:port.
  // 启用HTTP / 2
  -h2 Enable HTTP/2.
  // HTTP主机头
  -host HTTP Host header.
  // 禁用压缩。
  -disable-compression  Disable compression.
  // 禁用保持活动状态，防止重新使用不同的HTTP请求之间的TCP连接。
  -disable-keepalive    Disable keep-alive, prevents re-use of TCP
                        connections between different HTTP requests.
  // 禁用HTTP重定向                      
  -disable-redirects    Disable following of HTTP redirects
  // 使用的cpu内核数。当前计算机的默认值为8核。
  -cpus                 Number of used cpu cores.
                        (default for current machine is 8 cores)
```

#### Hey使用示例

```bash
# 并发400 持续120秒
hey -z 120s -c 400 http://localhost:8080/school/list
```

#### Hey测试结果解析

```
Summary:
  Total:    122.0965 secs
  Slowest:  18.8614 secs
  Fastest:  0.0005 secs
  Average:  0.2101 secs
  Requests/sec:  1685.4458
  
  Total data:  10038549 bytes
  Size/request:  48 bytes

Response time histogram:
  0.001 [1]  |
  1.887 [202711]  |■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
  3.773 [1460]  |
  5.659 [406]  |
  7.545 [211]  |
  9.431 [164]  |
  11.317 [22]  |
  13.203 [0]  |
  15.089 [23]  |
  16.975 [62]  |
  18.861 [21]  |


Latency distribution:
  10% in 0.0018 secs
  25% in 0.0026 secs
  50% in 0.0050 secs
  75% in 0.1091 secs
  90% in 0.5956 secs
  95% in 1.1385 secs
  99% in 2.3687 secs

Details (average, fastest, slowest):
  DNS+dialup:  0.0000 secs, 0.0005 secs, 18.8614 secs
  DNS-lookup:  0.0000 secs, 0.0000 secs, 0.0209 secs
  req write:  0.0000 secs, 0.0000 secs, 0.0213 secs
  resp wait:  0.2099 secs, 0.0005 secs, 18.8613 secs
  resp read:  0.0000 secs, 0.0000 secs, 0.0498 secs
```

### 2. wrk工具

Wrk是一个现代化的HTTP基准测试工具，它在单个多核CPU上运行时能够产生显著的负载。

#### wrk工具参数说明

```bash
wrk -c 400 -t 10 -d 120s -H "Authorization: Bearer pwd" --latency http://localhost:8080/user/list
```

#### 基本用法

```
连接数（c）与 QPS（q），请求响应时间毫秒（t）的关系大概可理解为：q = 1000/t * c
如果连接数是10，响应时间100毫秒，那么QPS就是 1000/100 * 10 = 100 (10个连接数，每个连接数每秒钟处理10个当然就是100啦)

wrk 4.2.0

使用方法: wrk <选项> <被测HTTP服务的URL>                            
  Options:                                              
    -c, --connections <N>  跟服务器建立并保持的TCP连接数量|连接数（connection）可以理解为并发数一般在测试过程中，这个值需要使用者不断向上调试，直至 QPS 达到一个临界点，便可认为此时的并发数为系统所能承受的最大并发量
    -d, --duration    <T>  压测时间            
    -t, --threads     <N>  使用多少个线程进行压测   一般是CPU核数，最大不要超过 CPUx2 核数，否则会带来额外的上下文切换将线程数设置为CPU核数主要是为了WRK 能最大化利用 CPU，使结果更准确
                                                      
    -s, --script      <S>  指定Lua脚本路径        
    -H, --header      <H>  为每一个HTTP请求添加HTTP头       
        --latency          在压测结束后，打印延迟统计信息    
        --timeout     <T>  超时时间      
    -v, --version          打印正在使用的wrk的详细版本信息
                                                      
  <N>代表数字参数，支持国际单位 (1k, 1M, 1G)
  <T>代表时间参数，支持时间单位 (2s, 2m, 2h)
```

#### wrk结果解析

```
Running 30s test @ www.bing.com （压测时间30s）
  8 threads and 200 connections （共8个测试线程，200个连接）
  Thread Stats   Avg      Stdev     Max   +/- Stdev
              （平均值） （标准差）（最大值）（正负一个标准差所占比例）
    Latency    46.67ms  215.38ms   1.67s    95.59%
    （延迟）
    Req/Sec     7.91k     1.15k   10.26k    70.77%
    （处理中的请求数）
  Latency Distribution （延迟分布）
     50%    2.93ms
     75%    3.78ms
     90%    4.73ms
     99%    1.35s （99分位的延迟）
  1790465 requests in 30.01s, 684.08MB read （30.01秒内共处理完成了1790465个请求，读取了684.08MB数据）
Requests/sec:  59658.29 （平均每秒处理完成59658.29个请求）
Transfer/sec:     22.79MB （平均每秒读取数据22.79MB）
```

#### 测试本机程序实例

**测试一：Redis连接池大小为10**

```
wrk -c 400 -t 10 -d 120

Running 2m test @ http://localhost:8080/user/list
  10 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   177.92ms  173.57ms   1.92s    95.73%
    Req/Sec   165.03    194.85     1.59k    89.84%
  Latency Distribution
     50%  200.67ms
     75%  213.85ms
     90%  239.46ms
     99%    1.07s 
  177071 requests in 2.00m, 29.24MB read
  Socket errors: connect 159, read 245, write 0, timeout 0
Requests/sec:   1474.36
Transfer/sec:    249.33KB
```

**测试二：Redis连接池大小为1000**

```
wrk -c 400 -t 10 -d 120

Running 2m test @ http://localhost:8080/user/list
  10 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   179.75ms  187.92ms   1.82s    95.75%
    Req/Sec   164.29    175.63     1.45k    90.18%
  Latency Distribution
     50%  198.88ms
     75%  207.98ms
     90%  224.15ms
     99%    1.23s 
  180130 requests in 2.00m, 29.79MB read
  Socket errors: connect 159, read 104, write 0, timeout 0
Requests/sec:   1499.81
Transfer/sec:    253.98KB
```

**MySQL查询压测**

```
wrk -c 400 -t 10 -d 120s -H "Authorization: Bearer pwd" --latency http://localhost:8080/school/list

Running 2m test @ http://localhost:8080/school/list
  10 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
```

## 五、代码实现

### 1. Web服务主程序

下面是一个使用Gin框架实现的简单Web服务，提供两个API接口用于性能测试：

```go
package main

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

func main() {
	engine := gin.Default()
	engine.GET("/user/list", userListHandler)
	engine.GET("/school/list", schoolListHandler)
	engine.Run(":8080")
}

// userListHandler /hello请求处理函数
func userListHandler(c *gin.Context) {
	userList, err := getUserList()
	if err != nil {
		c.JSON(http.StatusOK, err.Error())
		return
	}
	c.JSON(http.StatusOK, userList)
	return
}

type u struct {
	Name string `json:"name" gorm:"name"`
}

// schoolListHandler /hello请求处理函数
func schoolListHandler(c *gin.Context) {
	users := make([]*u, 0)
	z := DBClient.Table("user").Find(&users)
	if z.Error != nil {
		c.JSON(http.StatusOK, z.Error)
		return
	}
	c.JSON(http.StatusOK, users)
	return
}
```

### 2. MySQL数据库连接实现

以下是MySQL数据库连接的配置和初始化代码：

```go
package main

import (
	"fmt"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/schema"
	"strings"
)

var DBClient *gorm.DB

func init() {
	Setup()
}
func Setup() {
	d, err := InitDBClient(&MysqlConfig{
		Addr:       "localhost:3306",
		User:       "root",
		Passwd:     "123456",
		DB:         "test",
		Charset:    "utf8mb4",
		Options:    "parseTime=false",
		TimeoutSec: 1000,
		Tracing:    true,
	})
	if err != nil {
		panic(err)
	}
	DBClient = d
}

type MysqlConfig struct {
	Addr         string `toml:"addr" json:"addr" validate:"hostname_port" long:"addr"`
	User         string `toml:"user" json:"user" long:"user" description:"mysql user"`
	Passwd       string `toml:"passwd" json:"passwd" long:"passwd" description:"mysql passwd"`
	DB           string `toml:"db" json:"db" validate:"required" long:"db" description:"mysql database name"`
	MaxOpenCount int    `toml:"max_open_count" json:"max_open_count" validate:"required" long:"max_open_count"`
	MaxIdleCount int    `toml:"max_idle_count" json:"max_idle_count" validate:"required" long:"max_idle_count"`
	Charset      string `toml:"charset" json:"charset" long:"charset"`
	TimeoutSec   int    `toml:"timeout_sec" json:"timeout_sec" long:"timeout_sec"`
	Options      string `toml:"options" json:"options" long:"options"`
	Tracing      bool   `toml:"tracing" json:"tracing" long:"tracing"`
}

const MysqlDefaultCharset = "utf8mb4"

// InitDBClient InitDBClient
func InitDBClient(cfg *MysqlConfig) (*gorm.DB, error) {
	if cfg.Charset == "" {
		cfg.Charset = MysqlDefaultCharset
	}

	dsn := fmt.Sprintf("%s:%s@"+"tcp(%s)/%s?charset=%s",
		cfg.User, cfg.Passwd, cfg.Addr, cfg.DB, cfg.Charset)
	if cfg.TimeoutSec > 0 {
		// timeout in seconds has "s"
		dsn += fmt.Sprintf("&timeout=%ds", cfg.TimeoutSec)
	}
	if !strings.Contains(cfg.Options, "parseTime=") {
		dsn += "&parseTime=true"
	}
	if !strings.Contains(cfg.Options, "loc=") {
		dsn += "&loc=Local"
	}
	// other options
	if cfg.Options != "" {
		dsn += "&" + strings.Trim(cfg.Options, "&")
	}
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		NamingStrategy: schema.NamingStrategy{
			SingularTable: true,
		},
	})
	if err != nil {
		return nil, err
	}
	sqlDB, err := db.DB()
	if err != nil {
		return nil, err
	}
	if cfg.MaxIdleCount > 0 {
		sqlDB.SetMaxIdleConns(cfg.MaxIdleCount)
	}
	if cfg.MaxOpenCount > 0 {
		sqlDB.SetMaxOpenConns(cfg.MaxOpenCount)
	}
	return db, nil
}
```

### 3. Redis连接池实现

以下是Redis连接池的配置和操作代码：

```go
package main

import (
	"github.com/gomodule/redigo/redis"
	"time"
)

func getUserList() (string, error) {
	redis := NewRedisAi()
	get, err := redis.Get("user_list")
	if err != nil {
		return "", err
	}
	return get, nil
}

type RedisApi struct {
	redisPool   *redis.Pool
	redisServer string
}

func NewRedisAi() *RedisApi {
	pool := newRedisPoolWithSizeAndPasswd("127.0.0.1:6379", 1000, "")
	return &RedisApi{
		redisPool:   pool,
		redisServer: "127.0.0.1:6379",
	}
}

func (api *RedisApi) Get(key string) (value string, err error) {
	// 获取一条Redis连接
	redisConn := api.redisPool.Get()
	r, err := redisConn.Do("GET", key)
	value, err = redis.String(r, err)
	redisConn.Close()
	return value, err
}

func newRedisPoolWithSizeAndPasswd(redisServer string, maxPoolSize int, passwd string) *redis.Pool {
	poolSize := 1000
	if maxPoolSize != 0 {
		poolSize = maxPoolSize
	}
	healthCheckPeriod := time.Second * 30
	return &redis.Pool{
		// Maximum number of idle connections in the pool.
		MaxIdle: 20,
		// Maximum number of connections allocated by the pool at a given time.
		// When zero, there is no limit on the number of connections in the pool
		MaxActive: poolSize,
		// Close connections after remaining idle for this duration. If the value
		// is zero, then idle connections are not closed. Applications should set
		// the timeout to a value less than the server's timeout.
		IdleTimeout: 300 * time.Second,
		// If Wait is true and the pool is at the MaxActive limit, then Get() waits
		// for a connection to be returned to the pool before returning.
		Wait: false,
		// Dial is an application supplied function for creating and configuring a
		// connection.
		//
		// The connection returned from Dial must not be in a special state
		// (subscribed to pub sub channel, transaction started, ...).
		Dial: func() (redis.Conn, error) {
			c, err := redis.Dial("tcp", redisServer,
				redis.DialConnectTimeout(3*time.Second),
				// Read timeout on server should be greater than ping period.
				redis.DialReadTimeout(healthCheckPeriod+10*time.Second),
				redis.DialWriteTimeout(10*time.Second))
			if err != nil {
				return nil, err
			}
			// 密码非空才认证
			if passwd != "" {
				if _, err := c.Do("AUTH", passwd); err != nil {
					c.Close()
					return nil, err
				}
			}
			return c, err
		},
		// TestOnBorrow is an optional application supplied function for checking
		// the health of an idle connection before the connection is used again by
		// the application. Argument t is the time that the connection was returned
		// to the pool. If the function returns an error, then the connection is
		// closed.
		TestOnBorrow: func(c redis.Conn, t time.Time) error {
			if time.Since(t) < healthCheckPeriod {
				return nil
			}
			_, err := c.Do("PING")
			return err
		},
	}
}
```

## 六、性能测试与优化建议

通过以上内容，我们可以总结出以下性能测试和优化的建议：

1. **连接池优化**：
   - 根据测试结果，适当调整Redis连接池大小可以提高系统性能
   - MySQL连接池的最大连接数也需要根据实际负载进行调整

2. **并发控制**：
   - 了解系统的最大并发处理能力，设置合理的限流阈值
   - 使用工具如hey或wrk进行压测，找出系统瓶颈

3. **监控与告警**：
   - 关注TP50、TP99、TP999等关键性能指标
   - 建立完善的监控体系，及时发现性能问题

4. **服务保护**：
   - 实现熔断、限流、降级等机制，保护系统在高负载下的稳定性
   - 针对不同接口设置不同的QPS限制和超时策略

5. **性能分析**：
   - 使用pprof等工具进行性能分析，找出代码中的性能瓶颈
   - 定期进行性能测试，确保系统性能符合预期

通过合理的性能测试和优化，我们可以构建高性能、高可用的Web应用，为用户提供更好的体验。