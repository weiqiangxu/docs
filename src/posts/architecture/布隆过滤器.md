# 布隆过滤器

### 不存在的元素会被判定为存在。当整个位数租都是1的时候。

布隆过滤器（Bloom Filter）是一种空间效率极高的概率型数据结构，用于判断一个元素是否在一个集合中。

> 组成是位数组、一组哈希函数。快速地判断元素是否可能存在于集合中，但有一定的误判概率。

1. 创建一个长度为`m`的位数组，所有`位`初始化为`0`。
2. 定义`k`个不同的哈希函数。当元素加入集合时，这`k`个哈希函数分别计算出`k`个索引值，位数组中对应`k`个位置均为`1`。
3. 查询元素是否存在的时候，如果这**k个位置中有任何一个位为0**，那么这个元素**一定不存在于集合中**。
4. 这`k`个位置的位`全部为1`，那么这个元素可能存在于集合中。

```go
// 对于同一个数值k1用多个函数func计算得到多个位
// 这几个位都是1的时候那么标识元素是存在的
f1(k1) = index1
f2(k1) = index2
f3(k1) = index3
```

### 1.误判的原因

1. 哈希冲突. 如果`f1(A)`和`f2(B)`得到的位置都是`I`.那么就是哈希冲突.
2. 布隆过滤器中的元素数量增加，位数组中被置为`1`的位置也会越来越多。当元素数量接近甚至超过位数组所能表示的极限时，误判率会急剧上升。


### 2.如何减少误判

1. 根据预期的元素数量合理设计位数组大小。增大位数组大小`m`或者减小哈希函数个数`k`可以降低误判率。但增大`m`会增加空间成本，减小`k`可能会影响布隆过滤器的准确性。
2. 多层布隆过滤器。


### 3.本质上布隆过滤器解决哈希冲突的方式是

再哈希法（Re-Hashing）。准备多个hash函数，如果出现哈希冲突的时候，使用另一个哈希函数重新计算哈希地址，直到找到一个空闲位置。假设最初使用哈希函数 `h1(k)`，当冲突发生时，尝试使用 `h2(k)`，如果仍然冲突，再尝试 `h3(k)` 等，直到找到合适的位置。查找的时候先 `h1(k)` 发现k和此时的k不一致，在`h2(k)` 然后在 `h3(k)` ，直到找到key等于哈希表之中存储key一模一样的时候。