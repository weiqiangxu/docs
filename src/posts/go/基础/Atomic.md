# 原子操作

### 一、CAS（Compare-And-Swap）原理

    一种用于实现原子操作的机制，用于在多线程或多协程（Goroutine）环境下，安全地更新共享变量的值。内存位置（变量的地址）、预期旧值和新值。基本思想是先比较内存位置中的值是否等于预期旧值，如果相等，表示获取值到准备更新时候没有其他线程更改过这个数据，选择更新这个数据。


### 二、cas为什么是线程安全的

1. 执行值替换的动作是原子的

    CAS（Compare-And-Swap）操作是原子性的(硬件层面CPU通常会提供一些指令来支持原子操作)。原子性意味着整个操作在执行过程中是不可分割的，它不会被其他线程（或 Go 语言中的 Goroutine）中断。那么不原子的是什么样子呢，比如自增操作`count++`，这个操作在编译器层面可能会被分解为：读取`count`的值，将其加`1`，再将新值写回count的内存位置这三个步骤。三个线程分别获取了count的旧值然后执行`++`，就会出现结果异常的情况。

2. 基于预期旧值的比较机制

    比较内存位置中的当前值与预期旧值，每个线程更新之前，比较一下已经拿到的初始值，和内存之中的值，如果没有变才会更新，如果变了，说明在这个期间有其他线程更新了这个数据，那么会放弃修改这个值。

### 相关资料

- [很细致的性能对比 && 并发非安全引发错误示例](https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%92%8Catomic%E5%8C%85.html)
- [GO语言高性能编程](https://geektutu.com/post/high-performance-go.html)